{"version":3,"file":"formatTime.js","sources":["../../../../src/transformations/transformers/formatTime.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport { TimeZone } from '@grafana/schema';\n\nimport { DataFrame, Field, TransformationApplicabilityLevels } from '../../types';\nimport { DataTransformerInfo } from '../../types/transformations';\n\nimport { fieldToStringField } from './convertFieldType';\nimport { DataTransformerID } from './ids';\n\nexport interface FormatTimeTransformerOptions {\n  timeField: string;\n  outputFormat: string;\n  timezone: TimeZone;\n}\n\nexport const formatTimeTransformer: DataTransformerInfo<FormatTimeTransformerOptions> = {\n  id: DataTransformerID.formatTime,\n  name: 'Format time',\n  description: 'Set the output format of a time field',\n  defaultOptions: { timeField: '', outputFormat: '', useTimezone: true },\n  isApplicable: (data: DataFrame[]) => {\n    // Search for a time field\n    // if there is one then we can use this transformation\n    for (const frame of data) {\n      for (const field of frame.fields) {\n        if (field.type === 'time') {\n          return TransformationApplicabilityLevels.Applicable;\n        }\n      }\n    }\n\n    return TransformationApplicabilityLevels.NotApplicable;\n  },\n  isApplicableDescription:\n    'The Format time transformation requires a time field to work. No time field could be found.',\n  operator: (options) => (source) =>\n    source.pipe(\n      map((data) => {\n        // If a field and a format are configured\n        // then format the time output\n        const formatter = createTimeFormatter(options.timeField, options.outputFormat, options.timezone);\n\n        if (!Array.isArray(data) || data.length === 0) {\n          return data;\n        }\n\n        return data.map((frame) => ({\n          ...frame,\n          fields: formatter(frame.fields),\n        }));\n      })\n    ),\n};\n\n/**\n * @internal\n */\nexport const createTimeFormatter = (timeField: string, outputFormat: string, timezone: string) => (fields: Field[]) => {\n  return fields.map((field) => {\n    // Find the configured field\n    if (field.name === timeField) {\n      // Update values to use the configured format\n      let formattedField = null;\n      if (timezone) {\n        formattedField = fieldToStringField(field, outputFormat, { timeZone: timezone });\n      } else {\n        formattedField = fieldToStringField(field, outputFormat);\n      }\n\n      return formattedField;\n    }\n\n    return field;\n  });\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBO,MAAM,qBAA2E,GAAA;AAAA,EACtF,IAAI,iBAAkB,CAAA,UAAA;AAAA,EACtB,IAAM,EAAA,aAAA;AAAA,EACN,WAAa,EAAA,uCAAA;AAAA,EACb,gBAAgB,EAAE,SAAA,EAAW,IAAI,YAAc,EAAA,EAAA,EAAI,aAAa,IAAK,EAAA;AAAA,EACrE,YAAA,EAAc,CAAC,IAAsB,KAAA;AAGnC,IAAA,KAAA,MAAW,SAAS,IAAM,EAAA;AACxB,MAAW,KAAA,MAAA,KAAA,IAAS,MAAM,MAAQ,EAAA;AAChC,QAAI,IAAA,KAAA,CAAM,SAAS,MAAQ,EAAA;AACzB,UAAA,OAAO,iCAAkC,CAAA,UAAA,CAAA;AAAA,SAC3C;AAAA,OACF;AAAA,KACF;AAEA,IAAA,OAAO,iCAAkC,CAAA,aAAA,CAAA;AAAA,GAC3C;AAAA,EACA,uBACE,EAAA,6FAAA;AAAA,EACF,QAAU,EAAA,CAAC,OAAY,KAAA,CAAC,WACtB,MAAO,CAAA,IAAA;AAAA,IACL,GAAA,CAAI,CAAC,IAAS,KAAA;AAGZ,MAAA,MAAM,YAAY,mBAAoB,CAAA,OAAA,CAAQ,WAAW,OAAQ,CAAA,YAAA,EAAc,QAAQ,QAAQ,CAAA,CAAA;AAE/F,MAAA,IAAI,CAAC,KAAM,CAAA,OAAA,CAAQ,IAAI,CAAK,IAAA,IAAA,CAAK,WAAW,CAAG,EAAA;AAC7C,QAAO,OAAA,IAAA,CAAA;AAAA,OACT;AAEA,MAAA,OAAO,IAAK,CAAA,GAAA,CAAI,CAAC,KAAA,KAAW,iCACvB,KADuB,CAAA,EAAA;AAAA,QAE1B,MAAA,EAAQ,SAAU,CAAA,KAAA,CAAM,MAAM,CAAA;AAAA,OAC9B,CAAA,CAAA,CAAA;AAAA,KACH,CAAA;AAAA,GACH;AACJ,EAAA;AAKO,MAAM,sBAAsB,CAAC,SAAA,EAAmB,YAAsB,EAAA,QAAA,KAAqB,CAAC,MAAoB,KAAA;AACrH,EAAO,OAAA,MAAA,CAAO,GAAI,CAAA,CAAC,KAAU,KAAA;AAE3B,IAAI,IAAA,KAAA,CAAM,SAAS,SAAW,EAAA;AAE5B,MAAA,IAAI,cAAiB,GAAA,IAAA,CAAA;AACrB,MAAA,IAAI,QAAU,EAAA;AACZ,QAAA,cAAA,GAAiB,mBAAmB,KAAO,EAAA,YAAA,EAAc,EAAE,QAAA,EAAU,UAAU,CAAA,CAAA;AAAA,OAC1E,MAAA;AACL,QAAiB,cAAA,GAAA,kBAAA,CAAmB,OAAO,YAAY,CAAA,CAAA;AAAA,OACzD;AAEA,MAAO,OAAA,cAAA,CAAA;AAAA,KACT;AAEA,IAAO,OAAA,KAAA,CAAA;AAAA,GACR,CAAA,CAAA;AACH;;;;"}