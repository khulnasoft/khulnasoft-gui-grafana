{"version":3,"file":"processDataFrame.js","sources":["../../../src/dataframe/processDataFrame.ts"],"sourcesContent":["// Libraries\nimport { isArray, isBoolean, isNumber, isString } from 'lodash';\n\n// Types\nimport { isDateTime } from '../datetime/moment_wrapper';\nimport { fieldIndexComparer } from '../field/fieldComparers';\nimport { getFieldDisplayName } from '../field/fieldState';\nimport {\n  DataFrame,\n  Field,\n  FieldConfig,\n  TimeSeries,\n  FieldType,\n  TableData,\n  Column,\n  GraphSeriesXY,\n  TimeSeriesValue,\n  FieldDTO,\n  DataFrameDTO,\n  TIME_SERIES_VALUE_FIELD_NAME,\n  TIME_SERIES_TIME_FIELD_NAME,\n} from '../types/index';\nimport { ArrayVector } from '../vector/ArrayVector';\nimport { SortedVector } from '../vector/SortedVector';\nimport { vectorToArray } from '../vector/vectorToArray';\n\nimport { ArrayDataFrame } from './ArrayDataFrame';\nimport { dataFrameFromJSON } from './DataFrameJSON';\nimport { MutableDataFrame } from './MutableDataFrame';\n\nfunction convertTableToDataFrame(table: TableData): DataFrame {\n  const fields = table.columns.map((c) => {\n    // TODO: should be Column but type does not exists there so not sure whats up here.\n    const { text, type, ...disp } = c as any;\n    return {\n      name: text?.length ? text : c, // rename 'text' to the 'name' field\n      config: (disp || {}) as FieldConfig,\n      values: new ArrayVector(),\n      type: type && Object.values(FieldType).includes(type as FieldType) ? (type as FieldType) : FieldType.other,\n    };\n  });\n\n  if (!isArray(table.rows)) {\n    throw new Error(`Expected table rows to be array, got ${typeof table.rows}.`);\n  }\n\n  for (const row of table.rows) {\n    for (let i = 0; i < fields.length; i++) {\n      fields[i].values.buffer.push(row[i]);\n    }\n  }\n\n  for (const f of fields) {\n    if (f.type === FieldType.other) {\n      const t = guessFieldTypeForField(f);\n      if (t) {\n        f.type = t;\n      }\n    }\n  }\n\n  return {\n    fields,\n    refId: table.refId,\n    meta: table.meta,\n    name: table.name,\n    length: table.rows.length,\n  };\n}\n\nfunction convertTimeSeriesToDataFrame(timeSeries: TimeSeries): DataFrame {\n  const times: number[] = [];\n  const values: TimeSeriesValue[] = [];\n\n  // Sometimes the points are sent as datapoints\n  const points = timeSeries.datapoints || (timeSeries as any).points;\n  for (const point of points) {\n    values.push(point[0]);\n    times.push(point[1] as number);\n  }\n\n  const fields = [\n    {\n      name: TIME_SERIES_TIME_FIELD_NAME,\n      type: FieldType.time,\n      config: {},\n      values: new ArrayVector<number>(times),\n    },\n    {\n      name: TIME_SERIES_VALUE_FIELD_NAME,\n      type: FieldType.number,\n      config: {\n        unit: timeSeries.unit,\n      },\n      values: new ArrayVector<TimeSeriesValue>(values),\n      labels: timeSeries.tags,\n    },\n  ];\n\n  if (timeSeries.title) {\n    (fields[1].config as FieldConfig).displayNameFromDS = timeSeries.title;\n  }\n\n  return {\n    name: timeSeries.target || (timeSeries as any).name,\n    refId: timeSeries.refId,\n    meta: timeSeries.meta,\n    fields,\n    length: values.length,\n  };\n}\n\n/**\n * This is added temporarily while we convert the LogsModel\n * to DataFrame.  See: https://github.com/grafana/grafana/issues/18528\n */\nfunction convertGraphSeriesToDataFrame(graphSeries: GraphSeriesXY): DataFrame {\n  const x = new ArrayVector();\n  const y = new ArrayVector();\n\n  for (let i = 0; i < graphSeries.data.length; i++) {\n    const row = graphSeries.data[i];\n    x.buffer.push(row[1]);\n    y.buffer.push(row[0]);\n  }\n\n  return {\n    name: graphSeries.label,\n    fields: [\n      {\n        name: graphSeries.label || TIME_SERIES_VALUE_FIELD_NAME,\n        type: FieldType.number,\n        config: {},\n        values: x,\n      },\n      {\n        name: TIME_SERIES_TIME_FIELD_NAME,\n        type: FieldType.time,\n        config: {\n          unit: 'dateTimeAsIso',\n        },\n        values: y,\n      },\n    ],\n    length: x.buffer.length,\n  };\n}\n\nfunction convertJSONDocumentDataToDataFrame(timeSeries: TimeSeries): DataFrame {\n  const fields = [\n    {\n      name: timeSeries.target,\n      type: FieldType.other,\n      labels: timeSeries.tags,\n      config: {\n        unit: timeSeries.unit,\n        filterable: (timeSeries as any).filterable,\n      },\n      values: new ArrayVector(),\n    },\n  ];\n\n  for (const point of timeSeries.datapoints) {\n    fields[0].values.buffer.push(point);\n  }\n\n  return {\n    name: timeSeries.target,\n    refId: timeSeries.target,\n    meta: { json: true },\n    fields,\n    length: timeSeries.datapoints.length,\n  };\n}\n\n// PapaParse Dynamic Typing regex:\n// https://github.com/mholt/PapaParse/blob/master/papaparse.js#L998\nconst NUMBER = /^\\s*(-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?|NAN)\\s*$/i;\n\n/**\n * Given a name and value, this will pick a reasonable field type\n */\nexport function guessFieldTypeFromNameAndValue(name: string, v: any): FieldType {\n  if (name) {\n    name = name.toLowerCase();\n    if (name === 'date' || name === 'time') {\n      return FieldType.time;\n    }\n  }\n  return guessFieldTypeFromValue(v);\n}\n\n/**\n * Check the field type to see what the contents are\n */\nexport function getFieldTypeFromValue(v: any): FieldType {\n  if (v instanceof Date || isDateTime(v)) {\n    return FieldType.time;\n  }\n\n  if (isNumber(v)) {\n    return FieldType.number;\n  }\n\n  if (isString(v)) {\n    return FieldType.string;\n  }\n\n  if (isBoolean(v)) {\n    return FieldType.boolean;\n  }\n\n  return FieldType.other;\n}\n\n/**\n * Given a value this will guess the best column type\n *\n * NOTE: this is will try to see if string values can be mapped to other types (like number)\n */\nexport function guessFieldTypeFromValue(v: any): FieldType {\n  if (v instanceof Date || isDateTime(v)) {\n    return FieldType.time;\n  }\n\n  if (isNumber(v)) {\n    return FieldType.number;\n  }\n\n  if (isString(v)) {\n    if (NUMBER.test(v)) {\n      return FieldType.number;\n    }\n\n    if (v === 'true' || v === 'TRUE' || v === 'True' || v === 'false' || v === 'FALSE' || v === 'False') {\n      return FieldType.boolean;\n    }\n\n    return FieldType.string;\n  }\n\n  if (isBoolean(v)) {\n    return FieldType.boolean;\n  }\n\n  return FieldType.other;\n}\n\n/**\n * Looks at the data to guess the column type.  This ignores any existing setting\n */\nexport function guessFieldTypeForField(field: Field): FieldType | undefined {\n  // 1. Use the column name to guess\n  if (field.name) {\n    const name = field.name.toLowerCase();\n    if (name === 'date' || name === 'time') {\n      return FieldType.time;\n    }\n  }\n\n  // 2. Check the first non-null value\n  for (let i = 0; i < field.values.length; i++) {\n    const v = field.values.get(i);\n    if (v != null) {\n      return guessFieldTypeFromValue(v);\n    }\n  }\n\n  // Could not find anything\n  return undefined;\n}\n\n/**\n * @returns A copy of the series with the best guess for each field type.\n * If the series already has field types defined, they will be used, unless `guessDefined` is true.\n * @param series The DataFrame whose field's types should be guessed\n * @param guessDefined Whether to guess types of fields with already defined types\n */\nexport const guessFieldTypes = (series: DataFrame, guessDefined = false): DataFrame => {\n  for (const field of series.fields) {\n    if (!field.type || field.type === FieldType.other || guessDefined) {\n      // Something is missing a type, return a modified copy\n      return {\n        ...series,\n        fields: series.fields.map((field) => {\n          if (field.type && field.type !== FieldType.other && !guessDefined) {\n            return field;\n          }\n          // Calculate a reasonable schema value\n          return {\n            ...field,\n            type: guessFieldTypeForField(field) || FieldType.other,\n          };\n        }),\n      };\n    }\n  }\n  // No changes necessary\n  return series;\n};\n\nexport const isTableData = (data: any): data is DataFrame => data && data.hasOwnProperty('columns');\n\nexport const isDataFrame = (data: any): data is DataFrame => data && data.hasOwnProperty('fields');\n\n/**\n * Inspect any object and return the results as a DataFrame\n */\nexport function toDataFrame(data: any): DataFrame {\n  if ('fields' in data) {\n    // DataFrameDTO does not have length\n    if ('length' in data && data.fields[0]?.values?.get) {\n      return data as DataFrame;\n    }\n\n    // This will convert the array values into Vectors\n    return new MutableDataFrame(data as DataFrameDTO);\n  }\n\n  // Handle legacy docs/json type\n  if (data.hasOwnProperty('type') && data.type === 'docs') {\n    return convertJSONDocumentDataToDataFrame(data);\n  }\n\n  if (data.hasOwnProperty('datapoints') || data.hasOwnProperty('points')) {\n    return convertTimeSeriesToDataFrame(data);\n  }\n\n  if (data.hasOwnProperty('data')) {\n    if (data.hasOwnProperty('schema')) {\n      return dataFrameFromJSON(data);\n    }\n    return convertGraphSeriesToDataFrame(data);\n  }\n\n  if (data.hasOwnProperty('columns')) {\n    return convertTableToDataFrame(data);\n  }\n\n  if (Array.isArray(data)) {\n    return new ArrayDataFrame(data);\n  }\n\n  console.warn('Can not convert', data);\n  throw new Error('Unsupported data format');\n}\n\nexport const toLegacyResponseData = (frame: DataFrame): TimeSeries | TableData => {\n  const { fields } = frame;\n\n  const rowCount = frame.length;\n  const rows: any[][] = [];\n\n  if (fields.length === 2) {\n    const { timeField, timeIndex } = getTimeField(frame);\n    if (timeField) {\n      const valueIndex = timeIndex === 0 ? 1 : 0;\n      const valueField = fields[valueIndex];\n      const timeField = fields[timeIndex!];\n\n      // Make sure it is [value,time]\n      for (let i = 0; i < rowCount; i++) {\n        rows.push([\n          valueField.values.get(i), // value\n          timeField.values.get(i), // time\n        ]);\n      }\n\n      return {\n        alias: frame.name,\n        target: getFieldDisplayName(valueField, frame),\n        datapoints: rows,\n        unit: fields[0].config ? fields[0].config.unit : undefined,\n        refId: frame.refId,\n        meta: frame.meta,\n      } as TimeSeries;\n    }\n  }\n\n  for (let i = 0; i < rowCount; i++) {\n    const row: any[] = [];\n    for (let j = 0; j < fields.length; j++) {\n      row.push(fields[j].values.get(i));\n    }\n    rows.push(row);\n  }\n\n  if (frame.meta && frame.meta.json) {\n    return {\n      alias: fields[0].name || frame.name,\n      target: fields[0].name || frame.name,\n      datapoints: fields[0].values.toArray(),\n      filterable: fields[0].config ? fields[0].config.filterable : undefined,\n      type: 'docs',\n    } as TimeSeries;\n  }\n\n  return {\n    columns: fields.map((f) => {\n      const { name, config } = f;\n      if (config) {\n        // keep unit etc\n        const { ...column } = config;\n        (column as Column).text = name;\n        return column as Column;\n      }\n      return { text: name };\n    }),\n    type: 'table',\n    refId: frame.refId,\n    meta: frame.meta,\n    rows,\n  };\n};\n\nexport function sortDataFrame(data: DataFrame, sortIndex?: number, reverse = false): DataFrame {\n  const field = data.fields[sortIndex!];\n  if (!field) {\n    return data;\n  }\n\n  // Natural order\n  const index: number[] = [];\n  for (let i = 0; i < data.length; i++) {\n    index.push(i);\n  }\n\n  const fieldComparer = fieldIndexComparer(field, reverse);\n  index.sort(fieldComparer);\n\n  return {\n    ...data,\n    fields: data.fields.map((f) => {\n      return {\n        ...f,\n        values: new SortedVector(f.values, index),\n      };\n    }),\n  };\n}\n\n/**\n * Returns a copy with all values reversed\n */\nexport function reverseDataFrame(data: DataFrame): DataFrame {\n  return {\n    ...data,\n    fields: data.fields.map((f) => {\n      const copy = [...f.values.toArray()];\n      copy.reverse();\n      return {\n        ...f,\n        values: new ArrayVector(copy),\n      };\n    }),\n  };\n}\n\n/**\n * Wrapper to get an array from each field value\n */\nexport function getDataFrameRow(data: DataFrame, row: number): any[] {\n  const values: any[] = [];\n  for (const field of data.fields) {\n    values.push(field.values.get(row));\n  }\n  return values;\n}\n\n/**\n * Returns a copy that does not include functions\n */\nexport function toDataFrameDTO(data: DataFrame): DataFrameDTO {\n  return toFilteredDataFrameDTO(data);\n}\n\nexport function toFilteredDataFrameDTO(data: DataFrame, fieldPredicate?: (f: Field) => boolean): DataFrameDTO {\n  const filteredFields = fieldPredicate ? data.fields.filter(fieldPredicate) : data.fields;\n  const fields: FieldDTO[] = filteredFields.map((f) => {\n    let values = f.values.toArray();\n    // The byte buffers serialize like objects\n    if (values instanceof Float64Array) {\n      values = vectorToArray(f.values);\n    }\n    return {\n      name: f.name,\n      type: f.type,\n      config: f.config,\n      values,\n      labels: f.labels,\n    };\n  });\n\n  return {\n    fields,\n    refId: data.refId,\n    meta: data.meta,\n    name: data.name,\n  };\n}\n\nexport const getTimeField = (series: DataFrame): { timeField?: Field; timeIndex?: number } => {\n  for (let i = 0; i < series.fields.length; i++) {\n    if (series.fields[i].type === FieldType.time) {\n      return {\n        timeField: series.fields[i],\n        timeIndex: i,\n      };\n    }\n  }\n  return {};\n};\n"],"names":["field","timeField"],"mappings":"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"}