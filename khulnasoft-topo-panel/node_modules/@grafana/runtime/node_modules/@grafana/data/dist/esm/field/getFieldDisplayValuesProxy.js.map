{"version":3,"file":"getFieldDisplayValuesProxy.js","sources":["../../../src/field/getFieldDisplayValuesProxy.ts"],"sourcesContent":["import { toNumber } from 'lodash';\n\nimport { DataFrame, DisplayValue, TimeZone } from '../types';\nimport { formattedValueToString } from '../valueFormats';\n\nimport { getDisplayProcessor } from './displayProcessor';\n\n/**\n * Creates a proxy object that allows accessing fields on dataFrame through various means and then returns it's\n * display value. This is mainly useful for example in data links interpolation where you can easily create a scoped\n * variable that will allow you to access dataFrame data with ${__data.fields.fieldName}.\n * Allows accessing fields by name, index, displayName or 'name' label\n *\n * @param options\n * @internal\n */\nexport function getFieldDisplayValuesProxy(options: {\n  frame: DataFrame;\n  rowIndex: number;\n  timeZone?: TimeZone;\n}): Record<string, DisplayValue> {\n  return new Proxy({} as Record<string, DisplayValue>, {\n    get: (obj: any, key: string): DisplayValue | undefined => {\n      // 1. Match the name\n      let field = options.frame.fields.find((f) => key === f.name);\n      if (!field) {\n        // 2. Match the array index\n        const k = toNumber(key);\n        field = options.frame.fields[k];\n      }\n      if (!field) {\n        // 3. Match the config displayName\n        field = options.frame.fields.find((f) => key === f.config.displayName);\n      }\n      if (!field) {\n        // 4. Match the name label\n        field = options.frame.fields.find((f) => {\n          if (f.labels) {\n            return key === f.labels.name;\n          }\n          return false;\n        });\n      }\n      if (!field) {\n        return undefined;\n      }\n      // TODO: we could supply the field here for the getDisplayProcessor fallback but we would also need theme which\n      //  we do not have access to here\n      const displayProcessor = field.display ?? getDisplayProcessor();\n      const raw = field.values.get(options.rowIndex);\n      const disp = displayProcessor(raw);\n      disp.toString = () => formattedValueToString(disp);\n      return disp;\n    },\n  });\n}\n"],"names":[],"mappings":";;;;AAgBO,SAAS,2BAA2B,OAIV,EAAA;AAC/B,EAAO,OAAA,IAAI,KAAM,CAAA,EAAoC,EAAA;AAAA,IACnD,GAAA,EAAK,CAAC,GAAA,EAAU,GAA0C,KAAA;AAtB9D,MAAA,IAAA,EAAA,CAAA;AAwBM,MAAI,IAAA,KAAA,GAAQ,QAAQ,KAAM,CAAA,MAAA,CAAO,KAAK,CAAC,CAAA,KAAM,GAAQ,KAAA,CAAA,CAAE,IAAI,CAAA,CAAA;AAC3D,MAAA,IAAI,CAAC,KAAO,EAAA;AAEV,QAAM,MAAA,CAAA,GAAI,SAAS,GAAG,CAAA,CAAA;AACtB,QAAQ,KAAA,GAAA,OAAA,CAAQ,MAAM,MAAO,CAAA,CAAA,CAAA,CAAA;AAAA,OAC/B;AACA,MAAA,IAAI,CAAC,KAAO,EAAA;AAEV,QAAQ,KAAA,GAAA,OAAA,CAAQ,MAAM,MAAO,CAAA,IAAA,CAAK,CAAC,CAAM,KAAA,GAAA,KAAQ,CAAE,CAAA,MAAA,CAAO,WAAW,CAAA,CAAA;AAAA,OACvE;AACA,MAAA,IAAI,CAAC,KAAO,EAAA;AAEV,QAAA,KAAA,GAAQ,OAAQ,CAAA,KAAA,CAAM,MAAO,CAAA,IAAA,CAAK,CAAC,CAAM,KAAA;AACvC,UAAA,IAAI,EAAE,MAAQ,EAAA;AACZ,YAAO,OAAA,GAAA,KAAQ,EAAE,MAAO,CAAA,IAAA,CAAA;AAAA,WAC1B;AACA,UAAO,OAAA,KAAA,CAAA;AAAA,SACR,CAAA,CAAA;AAAA,OACH;AACA,MAAA,IAAI,CAAC,KAAO,EAAA;AACV,QAAO,OAAA,KAAA,CAAA,CAAA;AAAA,OACT;AAGA,MAAA,MAAM,gBAAmB,GAAA,CAAA,EAAA,GAAA,KAAA,CAAM,OAAN,KAAA,IAAA,GAAA,EAAA,GAAiB,mBAAoB,EAAA,CAAA;AAC9D,MAAA,MAAM,GAAM,GAAA,KAAA,CAAM,MAAO,CAAA,GAAA,CAAI,QAAQ,QAAQ,CAAA,CAAA;AAC7C,MAAM,MAAA,IAAA,GAAO,iBAAiB,GAAG,CAAA,CAAA;AACjC,MAAK,IAAA,CAAA,QAAA,GAAW,MAAM,sBAAA,CAAuB,IAAI,CAAA,CAAA;AACjD,MAAO,OAAA,IAAA,CAAA;AAAA,KACT;AAAA,GACD,CAAA,CAAA;AACH;;;;"}