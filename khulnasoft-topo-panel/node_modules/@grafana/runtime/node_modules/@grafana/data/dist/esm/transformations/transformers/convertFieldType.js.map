{"version":3,"file":"convertFieldType.js","sources":["../../../../src/transformations/transformers/convertFieldType.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport { dateTimeParse } from '../../datetime';\nimport { SynchronousDataTransformerInfo } from '../../types';\nimport { DataFrame, Field, FieldType } from '../../types/dataFrame';\nimport { ArrayVector } from '../../vector';\nimport { fieldMatchers } from '../matchers';\nimport { FieldMatcherID } from '../matchers/ids';\n\nimport { DataTransformerID } from './ids';\n\nexport interface ConvertFieldTypeTransformerOptions {\n  conversions: ConvertFieldTypeOptions[];\n}\n\nexport interface ConvertFieldTypeOptions {\n  /**\n   * The field to convert field type\n   */\n  targetField?: string;\n  /**\n   * The field type to convert to\n   */\n  destinationType?: FieldType;\n  /**\n   * Date format to parse a string datetime\n   */\n  dateFormat?: string;\n}\n\nexport const convertFieldTypeTransformer: SynchronousDataTransformerInfo<ConvertFieldTypeTransformerOptions> = {\n  id: DataTransformerID.convertFieldType,\n  name: 'Convert field type',\n  description: 'Convert a field to a specified field type',\n  defaultOptions: {\n    fields: {},\n    conversions: [{ targetField: undefined, destinationType: undefined, dateFormat: undefined }],\n  },\n\n  operator: (options) => (source) => source.pipe(map((data) => convertFieldTypeTransformer.transformer(options)(data))),\n\n  transformer: (options: ConvertFieldTypeTransformerOptions) => (data: DataFrame[]) => {\n    if (!Array.isArray(data) || data.length === 0) {\n      return data;\n    }\n    const timeParsed = convertFieldTypes(options, data);\n    if (!timeParsed) {\n      return [];\n    }\n    return timeParsed;\n  },\n};\n\n/**\n * Convert field types for dataframe(s)\n * @param options - field type conversion options\n * @param frames - dataframe(s) with field types to convert\n * @returns dataframe(s) with converted field types\n */\nexport function convertFieldTypes(options: ConvertFieldTypeTransformerOptions, frames: DataFrame[]): DataFrame[] {\n  if (!options.conversions.length) {\n    return frames;\n  }\n\n  const framesCopy = frames.map((frame) => ({ ...frame }));\n\n  for (const conversion of options.conversions) {\n    if (!conversion.targetField) {\n      continue;\n    }\n    const matches = fieldMatchers.get(FieldMatcherID.byName).get(conversion.targetField);\n    for (const frame of framesCopy) {\n      frame.fields = frame.fields.map((field) => {\n        if (matches(field, frame, framesCopy)) {\n          return convertFieldType(field, conversion);\n        }\n        return field;\n      });\n    }\n  }\n\n  return framesCopy;\n}\n\n/**\n * Convert a single field type to specified field type.\n * @param field - field to convert\n * @param opts - field conversion options\n * @returns converted field\n *\n * @internal\n */\nexport function convertFieldType(field: Field, opts: ConvertFieldTypeOptions): Field {\n  switch (opts.destinationType) {\n    case FieldType.time:\n      return ensureTimeField(field, opts.dateFormat);\n    case FieldType.number:\n      return fieldToNumberField(field);\n    case FieldType.string:\n      return fieldToStringField(field);\n    case FieldType.boolean:\n      return fieldToBooleanField(field);\n    case FieldType.other:\n      return fieldToComplexField(field);\n    default:\n      return field;\n  }\n}\n\n// matches ISO 8601, e.g. 2021-11-11T19:45:00.000Z (float portion optional)\nconst iso8601Regex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d{3})?Z$/;\n\n/**\n * @internal\n */\nexport function fieldToTimeField(field: Field, dateFormat?: string): Field {\n  let opts = dateFormat ? { format: dateFormat } : undefined;\n\n  const timeValues = field.values.toArray().slice();\n\n  let firstDefined = timeValues.find((v) => v != null);\n\n  let isISO8601 = typeof firstDefined === 'string' && iso8601Regex.test(firstDefined);\n\n  for (let t = 0; t < timeValues.length; t++) {\n    if (timeValues[t]) {\n      let parsed = isISO8601 ? Date.parse(timeValues[t]) : dateTimeParse(timeValues[t], opts).valueOf();\n      timeValues[t] = Number.isFinite(parsed) ? parsed : null;\n    } else {\n      timeValues[t] = null;\n    }\n  }\n\n  return {\n    ...field,\n    type: FieldType.time,\n    values: new ArrayVector(timeValues),\n  };\n}\n\nfunction fieldToNumberField(field: Field): Field {\n  const numValues = field.values.toArray().slice();\n\n  const valuesAsStrings = numValues.some((v) => typeof v === 'string');\n\n  for (let n = 0; n < numValues.length; n++) {\n    let toBeConverted = numValues[n];\n\n    if (valuesAsStrings) {\n      // some numbers returned from datasources have commas\n      // strip the commas, coerce the string to a number\n      toBeConverted = toBeConverted.replace(/,/g, '');\n    }\n\n    const number = +toBeConverted;\n\n    numValues[n] = Number.isFinite(number) ? number : null;\n  }\n\n  return {\n    ...field,\n    type: FieldType.number,\n    values: new ArrayVector(numValues),\n  };\n}\n\nfunction fieldToBooleanField(field: Field): Field {\n  const booleanValues = field.values.toArray().slice();\n\n  for (let b = 0; b < booleanValues.length; b++) {\n    booleanValues[b] = Boolean(!!booleanValues[b]);\n  }\n\n  return {\n    ...field,\n    type: FieldType.boolean,\n    values: new ArrayVector(booleanValues),\n  };\n}\n\nfunction fieldToStringField(field: Field): Field {\n  const stringValues = field.values.toArray().slice();\n\n  for (let s = 0; s < stringValues.length; s++) {\n    stringValues[s] = `${stringValues[s]}`;\n  }\n\n  return {\n    ...field,\n    type: FieldType.string,\n    values: new ArrayVector(stringValues),\n  };\n}\n\nfunction fieldToComplexField(field: Field): Field {\n  const complexValues = field.values.toArray().slice();\n\n  for (let s = 0; s < complexValues.length; s++) {\n    try {\n      complexValues[s] = JSON.parse(complexValues[s]);\n    } catch {\n      complexValues[s] = null;\n    }\n  }\n\n  return {\n    ...field,\n    type: FieldType.other,\n    values: new ArrayVector(complexValues),\n  };\n}\n\n/**\n * Checks the first value. Assumes any number should be time fieldtype. Otherwise attempts to make the fieldtype time.\n * @param field - field to ensure is a time fieldtype\n * @param dateFormat - date format used to parse a string datetime\n * @returns field as time\n *\n * @public\n */\nexport function ensureTimeField(field: Field, dateFormat?: string): Field {\n  const firstValueTypeIsNumber = typeof field.values.get(0) === 'number';\n  if (field.type === FieldType.time && firstValueTypeIsNumber) {\n    return field; //already time\n  }\n  if (firstValueTypeIsNumber) {\n    return {\n      ...field,\n      type: FieldType.time, //assumes it should be time\n    };\n  }\n  return fieldToTimeField(field, dateFormat);\n}\n"],"names":[],"mappings":"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"}