/**
 * TODO docs
 */
declare enum AxisPlacement {
    Auto = "auto",
    Bottom = "bottom",
    Hidden = "hidden",
    Left = "left",
    Right = "right",
    Top = "top"
}
/**
 * TODO docs
 */
declare enum AxisColorMode {
    Series = "series",
    Text = "text"
}
/**
 * TODO docs
 */
declare enum VisibilityMode {
    Always = "always",
    Auto = "auto",
    Never = "never"
}
/**
 * TODO docs
 */
declare enum GraphDrawStyle {
    Bars = "bars",
    Line = "line",
    Points = "points"
}
/**
 * TODO docs
 */
declare enum GraphTransform {
    Constant = "constant",
    NegativeY = "negative-Y"
}
/**
 * TODO docs
 */
declare enum LineInterpolation {
    Linear = "linear",
    Smooth = "smooth",
    StepAfter = "stepAfter",
    StepBefore = "stepBefore"
}
/**
 * TODO docs
 */
declare enum ScaleDistribution {
    Linear = "linear",
    Log = "log",
    Ordinal = "ordinal",
    Symlog = "symlog"
}
/**
 * TODO docs
 */
declare enum GraphGradientMode {
    Hue = "hue",
    None = "none",
    Opacity = "opacity",
    Scheme = "scheme"
}
/**
 * TODO docs
 */
declare enum StackingMode {
    None = "none",
    Normal = "normal",
    Percent = "percent"
}
/**
 * TODO docs
 */
declare enum BarAlignment {
    After = 1,
    Before = -1,
    Center = 0
}
/**
 * TODO docs
 */
declare enum ScaleOrientation {
    Horizontal = 0,
    Vertical = 1
}
/**
 * TODO docs
 */
declare enum ScaleDirection {
    Down = -1,
    Left = -1,
    Right = 1,
    Up = 1
}
/**
 * TODO docs
 */
interface LineStyle {
    dash?: Array<number>;
    fill?: ('solid' | 'dash' | 'dot' | 'square');
}
declare const defaultLineStyle: Partial<LineStyle>;
/**
 * TODO docs
 */
interface LineConfig {
    lineColor?: string;
    lineInterpolation?: LineInterpolation;
    lineStyle?: LineStyle;
    lineWidth?: number;
    /**
     * Indicate if null values should be treated as gaps or connected.
     * When the value is a number, it represents the maximum delta in the
     * X axis that should be considered connected.  For timeseries, this is milliseconds
     */
    spanNulls?: (boolean | number);
}
/**
 * TODO docs
 */
interface BarConfig {
    barAlignment?: BarAlignment;
    barMaxWidth?: number;
    barWidthFactor?: number;
}
/**
 * TODO docs
 */
interface FillConfig {
    fillBelowTo?: string;
    fillColor?: string;
    fillOpacity?: number;
}
/**
 * TODO docs
 */
interface PointsConfig {
    pointColor?: string;
    pointSize?: number;
    pointSymbol?: string;
    showPoints?: VisibilityMode;
}
/**
 * TODO docs
 */
interface ScaleDistributionConfig {
    linearThreshold?: number;
    log?: number;
    type: ScaleDistribution;
}
/**
 * TODO docs
 */
interface AxisConfig {
    axisCenteredZero?: boolean;
    axisColorMode?: AxisColorMode;
    axisGridShow?: boolean;
    axisLabel?: string;
    axisPlacement?: AxisPlacement;
    axisSoftMax?: number;
    axisSoftMin?: number;
    axisWidth?: number;
    scaleDistribution?: ScaleDistributionConfig;
}
/**
 * TODO docs
 */
interface HideSeriesConfig {
    legend: boolean;
    tooltip: boolean;
    viz: boolean;
}
/**
 * TODO docs
 */
interface StackingConfig {
    group?: string;
    mode?: StackingMode;
}
/**
 * TODO docs
 */
interface StackableFieldConfig {
    stacking?: StackingConfig;
}
/**
 * TODO docs
 */
interface HideableFieldConfig {
    hideFrom?: HideSeriesConfig;
}
/**
 * TODO docs
 */
declare enum GraphTresholdsStyleMode {
    Area = "area",
    Dashed = "dashed",
    DashedAndArea = "dashed+area",
    Line = "line",
    LineAndArea = "line+area",
    Off = "off",
    Series = "series"
}
/**
 * TODO docs
 */
interface GraphThresholdsStyleConfig {
    mode: GraphTresholdsStyleMode;
}
/**
 * TODO docs
 */
declare type LegendPlacement = ('bottom' | 'right');
/**
 * TODO docs
 * Note: "hidden" needs to remain as an option for plugins compatibility
 */
declare enum LegendDisplayMode {
    Hidden = "hidden",
    List = "list",
    Table = "table"
}
/**
 * TODO docs
 */
interface TableSortByFieldState {
    desc?: boolean;
    displayName: string;
}
/**
 * TODO docs
 */
interface SingleStatBaseOptions extends OptionsWithTextFormatting {
    orientation: VizOrientation;
    reduceOptions: ReduceDataOptions;
}
/**
 * TODO docs
 */
interface ReduceDataOptions {
    /**
     * When !values, pick one value for the whole field
     */
    calcs: Array<string>;
    /**
     * Which fields to show.  By default this is only numeric fields
     */
    fields?: string;
    /**
     * if showing all values limit
     */
    limit?: number;
    /**
     * If true show each row value
     */
    values?: boolean;
}
declare const defaultReduceDataOptions: Partial<ReduceDataOptions>;
/**
 * TODO docs
 */
declare enum VizOrientation {
    Auto = "auto",
    Horizontal = "horizontal",
    Vertical = "vertical"
}
/**
 * TODO docs
 */
interface OptionsWithTooltip {
    tooltip: VizTooltipOptions;
}
/**
 * TODO docs
 */
interface OptionsWithLegend {
    legend: VizLegendOptions;
}
/**
 * TODO docs
 */
interface OptionsWithTimezones {
    timezone?: Array<string>;
}
declare const defaultOptionsWithTimezones: Partial<OptionsWithTimezones>;
/**
 * TODO docs
 */
interface OptionsWithTextFormatting {
    text?: VizTextDisplayOptions;
}
/**
 * TODO docs
 */
declare enum BigValueColorMode {
    Background = "background",
    None = "none",
    Value = "value"
}
/**
 * TODO docs
 */
declare enum BigValueGraphMode {
    Area = "area",
    Line = "line",
    None = "none"
}
/**
 * TODO docs
 */
declare enum BigValueJustifyMode {
    Auto = "auto",
    Center = "center"
}
/**
 * TODO docs
 */
declare enum BigValueTextMode {
    Auto = "auto",
    Name = "name",
    None = "none",
    Value = "value",
    ValueAndName = "value_and_name"
}
/**
 * TODO -- should not be table specific!
 * TODO docs
 */
declare type FieldTextAlignment = ('auto' | 'left' | 'right' | 'center');
/**
 * TODO docs
 */
declare enum TableCellDisplayMode {
    Auto = "auto",
    BasicGauge = "basic",
    ColorBackground = "color-background",
    ColorBackgroundSolid = "color-background-solid",
    ColorText = "color-text",
    GradientGauge = "gradient-gauge",
    Image = "image",
    JSONView = "json-view",
    LcdGauge = "lcd-gauge"
}
/**
 * TODO docs
 */
interface VizTextDisplayOptions {
    /**
     * Explicit title text size
     */
    titleSize?: number;
    /**
     * Explicit value text size
     */
    valueSize?: number;
}
/**
 * TODO docs
 */
declare enum TooltipDisplayMode {
    Multi = "multi",
    None = "none",
    Single = "single"
}
/**
 * TODO docs
 */
declare enum SortOrder {
    Ascending = "asc",
    Descending = "desc",
    None = "none"
}
/**
 * TODO docs
 */
interface GraphFieldConfig extends LineConfig, FillConfig, PointsConfig, AxisConfig, BarConfig, StackableFieldConfig, HideableFieldConfig {
    drawStyle?: GraphDrawStyle;
    gradientMode?: GraphGradientMode;
    thresholdsStyle?: GraphThresholdsStyleConfig;
    transform?: GraphTransform;
}
/**
 * TODO docs
 */
interface VizLegendOptions {
    asTable?: boolean;
    calcs: Array<string>;
    displayMode: LegendDisplayMode;
    isVisible?: boolean;
    placement: LegendPlacement;
    showLegend: boolean;
    sortBy?: string;
    sortDesc?: boolean;
    width?: number;
}
declare const defaultVizLegendOptions: Partial<VizLegendOptions>;
/**
 * TODO docs
 */
declare enum BarGaugeDisplayMode {
    Basic = "basic",
    Gradient = "gradient",
    Lcd = "lcd"
}
/**
 * TODO docs
 */
interface TableFieldOptions {
    align: FieldTextAlignment;
    displayMode: TableCellDisplayMode;
    filterable?: boolean;
    hidden?: boolean;
    inspect: boolean;
    minWidth?: number;
    width?: number;
}
declare const defaultTableFieldOptions: Partial<TableFieldOptions>;
/**
 * TODO docs
 */
interface VizTooltipOptions {
    mode: TooltipDisplayMode;
    sort: SortOrder;
}

/**
 * TODO docs
 */
interface AnnotationTarget {
    limit: number;
    matchAny: boolean;
    tags: Array<string>;
    type: string;
}
declare const defaultAnnotationTarget: Partial<AnnotationTarget>;
/**
 * TODO docs
 * FROM: AnnotationQuery in grafana-data/src/types/annotations.ts
 */
interface AnnotationQuery {
    builtIn: number;
    /**
     * Datasource to use for annotation.
     */
    datasource: {
        type?: string;
        uid?: string;
    };
    /**
     * Whether annotation is enabled.
     */
    enable: boolean;
    /**
     * Whether to hide annotation.
     */
    hide?: boolean;
    /**
     * Annotation icon color.
     */
    iconColor?: string;
    /**
     * Name of annotation.
     */
    name?: string;
    /**
     * Query for annotation data.
     */
    rawQuery?: string;
    showIn: number;
    target?: AnnotationTarget;
    type: string;
}
declare const defaultAnnotationQuery: Partial<AnnotationQuery>;
/**
 * FROM: packages/grafana-data/src/types/templateVars.ts
 * TODO docs
 * TODO what about what's in public/app/features/types.ts?
 * TODO there appear to be a lot of different kinds of [template] vars here? if so need a disjunction
 */
interface VariableModel {
    label?: string;
    name: string;
    type: VariableType;
}
/**
 * FROM public/app/features/dashboard/state/DashboardModels.ts - ish
 * TODO docs
 */
interface DashboardLink {
    asDropdown: boolean;
    icon?: string;
    includeVars: boolean;
    keepTime: boolean;
    tags: Array<string>;
    targetBlank: boolean;
    title: string;
    tooltip?: string;
    type: DashboardLinkType;
    url?: string;
}
declare const defaultDashboardLink: Partial<DashboardLink>;
/**
 * TODO docs
 */
declare type DashboardLinkType = ('link' | 'dashboards');
/**
 * FROM: packages/grafana-data/src/types/templateVars.ts
 * TODO docs
 * TODO this implies some wider pattern/discriminated union, probably?
 */
declare type VariableType = ('query' | 'adhoc' | 'constant' | 'datasource' | 'interval' | 'textbox' | 'custom' | 'system');
/**
 * TODO docs
 */
declare enum FieldColorModeId {
    ContinuousGrYlRd = "continuous-GrYlRd",
    Fixed = "fixed",
    PaletteClassic = "palette-classic",
    PaletteSaturated = "palette-saturated",
    Thresholds = "thresholds"
}
/**
 * TODO docs
 */
declare type FieldColorSeriesByMode = ('min' | 'max' | 'last');
/**
 * TODO docs
 */
interface FieldColor {
    /**
     * Stores the fixed color value if mode is fixed
     */
    fixedColor?: string;
    /**
     * The main color scheme mode
     */
    mode: FieldColorModeId;
    /**
     * Some visualizations need to know how to assign a series color from by value color schemes
     */
    seriesBy?: FieldColorSeriesByMode;
}
interface GridPos {
    /**
     * Panel
     */
    h: number;
    /**
     * true if fixed
     */
    static?: boolean;
    /**
     * Panel
     */
    w: number;
    /**
     * Panel x
     */
    x: number;
    /**
     * Panel y
     */
    y: number;
}
declare const defaultGridPos: Partial<GridPos>;
/**
 * TODO docs
 */
interface Threshold {
    /**
     * TODO docs
     */
    color: string;
    /**
     * TODO docs
     * TODO are the values here enumerable into a disjunction?
     * Some seem to be listed in typescript comment
     */
    state?: string;
    /**
     * TODO docs
     * FIXME the corresponding typescript field is required/non-optional, but nulls currently appear here when serializing -Infinity to JSON
     */
    value?: number;
}
declare enum ThresholdsMode {
    Absolute = "absolute",
    Percentage = "percentage"
}
interface ThresholdsConfig {
    mode: ThresholdsMode;
    /**
     * Must be sorted by 'value', first value is always -Infinity
     */
    steps: Array<Threshold>;
}
declare const defaultThresholdsConfig: Partial<ThresholdsConfig>;
/**
 * TODO docs
 */
declare type ValueMapping = (ValueMap | RangeMap | RegexMap | SpecialValueMap);
/**
 * TODO docs
 */
declare enum MappingType {
    RangeToText = "range",
    RegexToText = "regex",
    SpecialValue = "special",
    ValueToText = "value"
}
/**
 * TODO docs
 */
interface ValueMap {
    options: Record<string, unknown>;
    type: MappingType.ValueToText;
}
/**
 * TODO docs
 */
interface RangeMap {
    options: {
        /**
         * to and from are `number | null` in current ts, really not sure what to do
         */
        from: number;
        to: number;
        result: ValueMappingResult;
    };
    type: MappingType.RangeToText;
}
/**
 * TODO docs
 */
interface RegexMap {
    options: {
        pattern: string;
        result: ValueMappingResult;
    };
    type: MappingType.RegexToText;
}
/**
 * TODO docs
 */
interface SpecialValueMap {
    options: {
        match: ('true' | 'false');
        pattern: string;
        result: ValueMappingResult;
    };
    type: MappingType.SpecialValue;
}
/**
 * TODO docs
 */
declare enum SpecialValueMatch {
    Empty = "empty",
    False = "false",
    NaN = "nan",
    Null = "null",
    NullAndNan = "null+nan",
    True = "true"
}
/**
 * TODO docs
 */
interface ValueMappingResult {
    color?: string;
    icon?: string;
    index?: number;
    text?: string;
}
/**
 * TODO docs
 * FIXME this is extremely underspecfied; wasn't obvious which typescript types corresponded to it
 */
interface Transformation {
    id: string;
    options: Record<string, unknown>;
}
/**
 * 0 for no shared crosshair or tooltip (default).
 * 1 for shared crosshair.
 * 2 for shared crosshair AND shared tooltip.
 */
declare enum DashboardCursorSync {
    Crosshair = 1,
    Off = 0,
    Tooltip = 2
}
declare const defaultDashboardCursorSync: DashboardCursorSync;
/**
 * Dashboard panels. Panels are canonically defined inline
 * because they share a version timeline with the dashboard
 * schema; they do not evolve independently.
 */
interface Panel$1 {
    /**
     * The datasource used in all targets.
     */
    datasource?: {
        type?: string;
        uid?: string;
    };
    /**
     * Description.
     */
    description?: string;
    fieldConfig: FieldConfigSource$1;
    /**
     * Grid position.
     */
    gridPos?: GridPos;
    /**
     * TODO docs
     */
    id?: number;
    /**
     * TODO docs
     * TODO tighter constraint
     */
    interval?: string;
    /**
     * Panel links.
     * TODO fill this out - seems there are a couple variants?
     */
    links?: Array<DashboardLink>;
    /**
     * TODO docs
     */
    maxDataPoints?: number;
    /**
     * options is specified by the PanelOptions field in panel
     * plugin schemas.
     */
    options: Record<string, unknown>;
    /**
     * FIXME this almost certainly has to be changed in favor of scuemata versions
     */
    pluginVersion?: string;
    /**
     * Name of template variable to repeat for.
     */
    repeat?: string;
    /**
     * Direction to repeat in if 'repeat' is set.
     * "h" for horizontal, "v" for vertical.
     */
    repeatDirection: ('h' | 'v');
    /**
     * TODO docs
     */
    tags?: Array<string>;
    /**
     * TODO docs
     */
    targets?: Array<Record<string, unknown>>;
    /**
     * TODO docs - seems to be an old field from old dashboard alerts?
     */
    thresholds?: Array<any>;
    /**
     * TODO docs
     * TODO tighter constraint
     */
    timeFrom?: string;
    /**
     * TODO docs
     */
    timeRegions?: Array<any>;
    /**
     * TODO docs
     * TODO tighter constraint
     */
    timeShift?: string;
    /**
     * Panel title.
     */
    title?: string;
    transformations: Array<Transformation>;
    /**
     * Whether to display the panel without a background.
     */
    transparent: boolean;
    /**
     * The panel plugin type id. May not be empty.
     */
    type: string;
}
interface FieldConfigSource$1 {
    defaults: FieldConfig$1;
    overrides: Array<{
        matcher: MatcherConfig;
        properties: Array<{
            id: string;
            value?: any;
        }>;
    }>;
}
interface MatcherConfig {
    id: string;
    options?: any;
}
declare const defaultMatcherConfig: Partial<MatcherConfig>;
interface FieldConfig$1 {
    /**
     * Map values to a display color
     */
    color?: FieldColor;
    /**
     * custom is specified by the PanelFieldConfig field
     * in panel plugin schemas.
     */
    custom?: Record<string, unknown>;
    /**
     * Significant digits (for display)
     */
    decimals?: number;
    /**
     * Human readable field metadata
     */
    description?: string;
    /**
     * The display value for this field.  This supports template variables blank is auto
     */
    displayName?: string;
    /**
     * This can be used by data sources that return and explicit naming structure for values and labels
     * When this property is configured, this value is used rather than the default naming strategy.
     */
    displayNameFromDS?: string;
    /**
     * True if data source field supports ad-hoc filters
     */
    filterable?: boolean;
    /**
     * The behavior when clicking on a result
     */
    links?: Array<any>;
    /**
     * Convert input values into a display string
     */
    mappings?: Array<ValueMapping>;
    max?: number;
    min?: number;
    /**
     * Alternative to empty string
     */
    noValue?: string;
    /**
     * An explicit path to the field in the datasource.  When the frame meta includes a path,
     * This will default to `${frame.meta.path}/${field.name}
     *
     * When defined, this value can be used as an identifier within the datasource scope, and
     * may be used to update the results
     */
    path?: string;
    /**
     * Map numeric values to states
     */
    thresholds?: ThresholdsConfig;
    /**
     * Numeric Options
     */
    unit?: string;
    /**
     * True if data source can write a value to the path.  Auth/authz are supported separately
     */
    writeable?: boolean;
}
/**
 * Row panel
 */
interface RowPanel {
    collapsed: boolean;
    /**
     * Name of default datasource.
     */
    datasource?: {
        type?: string;
        uid?: string;
    };
    gridPos?: GridPos;
    id: number;
    panels: Array<(Panel$1 | {
        type: 'graph';
    } | {
        type: 'heatmap';
    })>;
    /**
     * Name of template variable to repeat for.
     */
    repeat?: string;
    title?: string;
    type: 'row';
}
declare const defaultRowPanel: Partial<RowPanel>;
interface Dashboard$1 {
    /**
     * TODO docs
     */
    annotations?: {
        list: Array<AnnotationQuery>;
    };
    /**
     * Description of dashboard.
     */
    description?: string;
    /**
     * Whether a dashboard is editable or not.
     */
    editable: boolean;
    /**
     * TODO docs
     */
    fiscalYearStartMonth?: number;
    gnetId?: string;
    graphTooltip: DashboardCursorSync;
    /**
     * Unique numeric identifier for the dashboard.
     * TODO must isolate or remove identifiers local to a Grafana instance...?
     */
    id?: number;
    /**
     * TODO docs
     */
    links?: Array<DashboardLink>;
    /**
     * TODO docs
     */
    liveNow?: boolean;
    panels?: Array<(Panel$1 | RowPanel | {
        type: 'graph';
    } | {
        type: 'heatmap';
    })>;
    /**
     * TODO docs
     */
    refresh?: (string | false);
    /**
     * Version of the JSON schema, incremented each time a Grafana update brings
     * changes to said schema.
     * TODO this is the existing schema numbering system. It will be replaced by Thema's themaVersion
     */
    schemaVersion: number;
    /**
     * Theme of dashboard.
     */
    style: ('light' | 'dark');
    /**
     * Tags associated with dashboard.
     */
    tags?: Array<string>;
    /**
     * TODO docs
     */
    templating?: {
        list: Array<VariableModel>;
    };
    /**
     * Time range for dashboard, e.g. last 6 hours, last 7 days, etc
     */
    time?: {
        from: string;
        to: string;
    };
    /**
     * TODO docs
     * TODO this appears to be spread all over in the frontend. Concepts will likely need tidying in tandem with schema changes
     */
    timepicker?: {
        /**
         * Whether timepicker is collapsed or not.
         */
        collapse: boolean;
        /**
         * Whether timepicker is enabled or not.
         */
        enable: boolean;
        /**
         * Whether timepicker is visible or not.
         */
        hidden: boolean;
        /**
         * Selectable intervals for auto-refresh.
         */
        refresh_intervals: Array<string>;
        /**
         * TODO docs
         */
        time_options: Array<string>;
    };
    /**
     * Timezone of dashboard,
     */
    timezone?: ('browser' | 'utc' | '');
    /**
     * Title of dashboard.
     */
    title?: string;
    /**
     * Unique dashboard identifier that can be generated by anyone. string (8-40)
     */
    uid?: string;
    /**
     * Version of the dashboard, incremented each time the dashboard is updated.
     */
    version?: number;
    /**
     * TODO docs
     */
    weekStart?: string;
}

interface Dashboard extends Dashboard$1 {
    panels?: Array<Panel | RowPanel | {
        type: 'graph';
    } | {
        type: 'heatmap';
    }>;
}
interface Panel<TOptions = Record<string, unknown>, TCustomFieldConfig = Record<string, unknown>> extends Panel$1 {
    fieldConfig: FieldConfigSource<TCustomFieldConfig>;
}
interface FieldConfig<TOptions = Record<string, unknown>> extends FieldConfig$1 {
    custom?: TOptions & Record<string, unknown>;
}
interface FieldConfigSource<TOptions = Record<string, unknown>> extends FieldConfigSource$1 {
    defaults: FieldConfig<TOptions>;
}
declare const defaultDashboard: Partial<Dashboard>;
declare const defaultPanel: Partial<Panel>;
declare const defaultFieldConfig: Partial<FieldConfig>;
declare const defaultFieldConfigSource: Partial<FieldConfigSource>;

interface PlaylistItem {
    /**
     * Title is an unused property -- it will be removed in the future
     */
    title?: string;
    /**
     * Type of the item.
     */
    type: ('dashboard_by_uid' | 'dashboard_by_id' | 'dashboard_by_tag');
    /**
     * Value depends on type and describes the playlist item.
     *
     *  - dashboard_by_id: The value is an internal numerical identifier set by Grafana. This
     *  is not portable as the numerical identifier is non-deterministic between different instances.
     *  Will be replaced by dashboard_by_uid in the future. (deprecated)
     *  - dashboard_by_tag: The value is a tag which is set on any number of dashboards. All
     *  dashboards behind the tag will be added to the playlist.
     *  - dashboard_by_uid: The value is the dashboard UID
     */
    value: string;
}
interface Playlist {
    /**
     * Interval sets the time between switching views in a playlist.
     * FIXME: Is this based on a standardized format or what options are available? Can datemath be used?
     */
    interval: string;
    /**
     * The ordered list of items that the playlist will iterate over.
     * FIXME! This should not be optional, but changing it makes the godegen awkward
     */
    items?: Array<PlaylistItem>;
    /**
     * Name of the playlist.
     */
    name: string;
    /**
     * Unique playlist identifier. Generated on creation, either by the
     * creator of the playlist of by the application.
     */
    uid: string;
}
declare const defaultPlaylist: Partial<Playlist>;

export { AnnotationQuery, AnnotationTarget, AxisColorMode, AxisConfig, AxisPlacement, BarAlignment, BarConfig, BarGaugeDisplayMode, BigValueColorMode, BigValueGraphMode, BigValueJustifyMode, BigValueTextMode, Dashboard, DashboardCursorSync, DashboardLink, DashboardLinkType, FieldColor, FieldColorModeId, FieldColorSeriesByMode, FieldConfig, FieldConfigSource, FieldTextAlignment, FillConfig, GraphDrawStyle, GraphFieldConfig, GraphGradientMode, GraphThresholdsStyleConfig, GraphTransform, GraphTresholdsStyleMode, GridPos, HideSeriesConfig, HideableFieldConfig, LegendDisplayMode, LegendPlacement, LineConfig, LineInterpolation, LineStyle, MappingType, MatcherConfig, OptionsWithLegend, OptionsWithTextFormatting, OptionsWithTimezones, OptionsWithTooltip, Panel, Playlist, PlaylistItem, PointsConfig, RangeMap, ReduceDataOptions, RegexMap, RowPanel, ScaleDirection, ScaleDistribution, ScaleDistributionConfig, ScaleOrientation, SingleStatBaseOptions, SortOrder, SpecialValueMap, SpecialValueMatch, StackableFieldConfig, StackingConfig, StackingMode, TableCellDisplayMode, TableFieldOptions, TableSortByFieldState, Threshold, ThresholdsConfig, ThresholdsMode, TooltipDisplayMode, Transformation, ValueMap, ValueMapping, ValueMappingResult, VariableModel, VariableType, VisibilityMode, VizLegendOptions, VizOrientation, VizTextDisplayOptions, VizTooltipOptions, defaultAnnotationQuery, defaultAnnotationTarget, defaultDashboard, defaultDashboardCursorSync, defaultDashboardLink, defaultFieldConfig, defaultFieldConfigSource, defaultGridPos, defaultLineStyle, defaultMatcherConfig, defaultOptionsWithTimezones, defaultPanel, defaultPlaylist, defaultReduceDataOptions, defaultRowPanel, defaultTableFieldOptions, defaultThresholdsConfig, defaultVizLegendOptions };
