import { isNumber } from 'lodash';
import { isObject, getObjectName, getType, cssClass, createElement, getValuePreview } from './helpers.js';

const DATE_STRING_REGEX = /(^\d{1,4}[\.|\\/|-]\d{1,2}[\.|\\/|-]\d{1,4})(\s*(?:0?[1-9]:[0-5]|1(?=[012])\d:[0-5])\d\s*[ap]m)?$/;
const PARTIAL_DATE_REGEX = /\d{2}:\d{2}:\d{2} GMT-\d{4}/;
const JSON_DATE_REGEX = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/;
const MAX_ANIMATED_TOGGLE_ITEMS = 10;
const requestAnimationFrame = typeof window !== "undefined" && window.requestAnimationFrame || ((cb) => {
  cb();
  return 0;
});
const _defaultConfig = {
  animateOpen: true,
  animateClose: true
};
class JsonExplorer {
  constructor(json, open = 1, config = _defaultConfig, key) {
    this.json = json;
    this.open = open;
    this.config = config;
    this.key = key;
    this._isOpen = null;
    this.element = null;
    this.skipChildren = false;
  }
  get isOpen() {
    if (this._isOpen !== null) {
      return this._isOpen;
    } else {
      return this.open > 0;
    }
  }
  set isOpen(value) {
    this._isOpen = value;
  }
  get isDate() {
    return this.type === "string" && (DATE_STRING_REGEX.test(this.json) || JSON_DATE_REGEX.test(this.json) || PARTIAL_DATE_REGEX.test(this.json));
  }
  get isUrl() {
    return this.type === "string" && this.json.indexOf("http") === 0;
  }
  get isArray() {
    return Array.isArray(this.json);
  }
  get isObject() {
    return isObject(this.json);
  }
  get isEmptyObject() {
    return !this.keys.length && !this.isArray;
  }
  get isEmpty() {
    return this.isEmptyObject || this.keys && !this.keys.length && this.isArray;
  }
  get hasKey() {
    return typeof this.key !== "undefined";
  }
  get constructorName() {
    return getObjectName(this.json);
  }
  get type() {
    return getType(this.json);
  }
  get keys() {
    if (this.isObject) {
      return Object.keys(this.json).map((key) => key ? key : '""');
    } else {
      return [];
    }
  }
  toggleOpen() {
    this.isOpen = !this.isOpen;
    if (this.element) {
      if (this.isOpen) {
        this.appendChildren(this.config.animateOpen);
      } else {
        this.removeChildren(this.config.animateClose);
      }
      this.element.classList.toggle(cssClass("open"));
    }
  }
  openAtDepth(depth = 1) {
    if (depth < 0) {
      return;
    }
    this.open = depth;
    this.isOpen = depth !== 0;
    if (this.element) {
      this.removeChildren(false);
      if (depth === 0) {
        this.element.classList.remove(cssClass("open"));
      } else {
        this.appendChildren(this.config.animateOpen);
        this.element.classList.add(cssClass("open"));
      }
    }
  }
  isNumberArray() {
    return this.json.length > 0 && this.json.length < 4 && (isNumber(this.json[0]) || isNumber(this.json[1]));
  }
  renderArray() {
    const arrayWrapperSpan = createElement("span");
    arrayWrapperSpan.appendChild(createElement("span", "bracket", "["));
    if (this.isNumberArray()) {
      this.json.forEach((val, index) => {
        if (index > 0) {
          arrayWrapperSpan.appendChild(createElement("span", "array-comma", ","));
        }
        arrayWrapperSpan.appendChild(createElement("span", "number", val));
      });
      this.skipChildren = true;
    } else {
      arrayWrapperSpan.appendChild(createElement("span", "number", this.json.length));
    }
    arrayWrapperSpan.appendChild(createElement("span", "bracket", "]"));
    return arrayWrapperSpan;
  }
  render(skipRoot = false) {
    this.element = createElement("div", "row");
    const togglerLink = createElement("a", "toggler-link");
    const togglerIcon = createElement("span", "toggler");
    if (this.isObject) {
      togglerLink.appendChild(togglerIcon);
    }
    if (this.hasKey) {
      togglerLink.appendChild(createElement("span", "key", `${this.key}:`));
    }
    if (this.isObject) {
      const value = createElement("span", "value");
      const objectWrapperSpan = createElement("span");
      const constructorName = createElement("span", "constructor-name", this.constructorName);
      objectWrapperSpan.appendChild(constructorName);
      if (this.isArray) {
        const arrayWrapperSpan = this.renderArray();
        objectWrapperSpan.appendChild(arrayWrapperSpan);
      }
      value.appendChild(objectWrapperSpan);
      togglerLink.appendChild(value);
    } else {
      const value = this.isUrl ? createElement("a") : createElement("span");
      value.classList.add(cssClass(this.type));
      if (this.isDate) {
        value.classList.add(cssClass("date"));
      }
      if (this.isUrl) {
        value.classList.add(cssClass("url"));
        value.setAttribute("href", this.json);
      }
      const valuePreview = getValuePreview(this.json, this.json);
      value.appendChild(document.createTextNode(valuePreview));
      togglerLink.appendChild(value);
    }
    const children = createElement("div", "children");
    if (this.isObject) {
      children.classList.add(cssClass("object"));
    }
    if (this.isArray) {
      children.classList.add(cssClass("array"));
    }
    if (this.isEmpty) {
      children.classList.add(cssClass("empty"));
    }
    if (this.config && this.config.theme) {
      this.element.classList.add(cssClass(this.config.theme));
    }
    if (this.isOpen) {
      this.element.classList.add(cssClass("open"));
    }
    if (!skipRoot) {
      this.element.appendChild(togglerLink);
    }
    if (!this.skipChildren) {
      this.element.appendChild(children);
    } else {
      togglerLink.removeChild(togglerIcon);
    }
    if (this.isObject && this.isOpen) {
      this.appendChildren();
    }
    if (this.isObject) {
      togglerLink.addEventListener("click", this.toggleOpen.bind(this));
    }
    return this.element;
  }
  appendChildren(animated = false) {
    const children = this.element && this.element.querySelector(`div.${cssClass("children")}`);
    if (!children || this.isEmpty) {
      return;
    }
    if (animated) {
      let index = 0;
      const addAChild = () => {
        const key = this.keys[index];
        const formatter = new JsonExplorer(this.json[key], this.open - 1, this.config, key);
        children.appendChild(formatter.render());
        index += 1;
        if (index < this.keys.length) {
          if (index > MAX_ANIMATED_TOGGLE_ITEMS) {
            addAChild();
          } else {
            requestAnimationFrame(addAChild);
          }
        }
      };
      requestAnimationFrame(addAChild);
    } else {
      this.keys.forEach((key) => {
        const formatter = new JsonExplorer(this.json[key], this.open - 1, this.config, key);
        children.appendChild(formatter.render());
      });
    }
  }
  removeChildren(animated = false) {
    const childrenElement = this.element && this.element.querySelector(`div.${cssClass("children")}`);
    if (animated) {
      let childrenRemoved = 0;
      const removeAChild = () => {
        if (childrenElement && childrenElement.children.length) {
          childrenElement.removeChild(childrenElement.children[0]);
          childrenRemoved += 1;
          if (childrenRemoved > MAX_ANIMATED_TOGGLE_ITEMS) {
            removeAChild();
          } else {
            requestAnimationFrame(removeAChild);
          }
        }
      };
      requestAnimationFrame(removeAChild);
    } else {
      if (childrenElement) {
        childrenElement.innerHTML = "";
      }
    }
  }
}

export { JsonExplorer };
//# sourceMappingURL=json_explorer.js.map
