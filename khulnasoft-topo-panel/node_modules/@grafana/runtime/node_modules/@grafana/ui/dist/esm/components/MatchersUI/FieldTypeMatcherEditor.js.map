{"version":3,"file":"FieldTypeMatcherEditor.js","sources":["../../../../src/components/MatchersUI/FieldTypeMatcherEditor.tsx"],"sourcesContent":["import React, { memo, useMemo, useCallback } from 'react';\n\nimport { FieldMatcherID, fieldMatchers, SelectableValue, FieldType, DataFrame } from '@grafana/data';\n\nimport { Select } from '../Select/Select';\n\nimport { MatcherUIProps, FieldMatcherUIRegistryItem } from './types';\n\nexport const FieldTypeMatcherEditor = memo<MatcherUIProps<string>>((props) => {\n  const { data, options, onChange: onChangeFromProps, id } = props;\n  const counts = useFieldCounts(data);\n  const selectOptions = useSelectOptions(counts, options);\n\n  const onChange = useCallback(\n    (selection: SelectableValue<string>) => {\n      return onChangeFromProps(selection.value!);\n    },\n    [onChangeFromProps]\n  );\n\n  const selectedOption = selectOptions.find((v) => v.value === options);\n  return <Select inputId={id} value={selectedOption} options={selectOptions} onChange={onChange} />;\n});\nFieldTypeMatcherEditor.displayName = 'FieldTypeMatcherEditor';\n\nconst allTypes: Array<SelectableValue<FieldType>> = [\n  { value: FieldType.number, label: 'Numeric' },\n  { value: FieldType.string, label: 'String' },\n  { value: FieldType.time, label: 'Time' },\n  { value: FieldType.boolean, label: 'Boolean' },\n  { value: FieldType.trace, label: 'Traces' },\n  { value: FieldType.other, label: 'Other' },\n];\n\nconst useFieldCounts = (data: DataFrame[]): Map<FieldType, number> => {\n  return useMemo(() => {\n    const counts: Map<FieldType, number> = new Map();\n    for (const t of allTypes) {\n      counts.set(t.value!, 0);\n    }\n    for (const frame of data) {\n      for (const field of frame.fields) {\n        const key = field.type || FieldType.other;\n        let v = counts.get(key);\n        if (!v) {\n          v = 0;\n        }\n        counts.set(key, v + 1);\n      }\n    }\n    return counts;\n  }, [data]);\n};\n\nconst useSelectOptions = (counts: Map<string, number>, opt?: string): Array<SelectableValue<string>> => {\n  return useMemo(() => {\n    let found = false;\n    const options: Array<SelectableValue<string>> = [];\n    for (const t of allTypes) {\n      const count = counts.get(t.value!);\n      const match = opt === t.value;\n      if (count || match) {\n        options.push({\n          ...t,\n          label: `${t.label} (${counts.get(t.value!)})`,\n        });\n      }\n      if (match) {\n        found = true;\n      }\n    }\n    if (opt && !found) {\n      options.push({\n        value: opt,\n        label: `${opt} (No matches)`,\n      });\n    }\n    return options;\n  }, [counts, opt]);\n};\n\nexport const fieldTypeMatcherItem: FieldMatcherUIRegistryItem<string> = {\n  id: FieldMatcherID.byType,\n  component: FieldTypeMatcherEditor,\n  matcher: fieldMatchers.get(FieldMatcherID.byType),\n  name: 'Fields with type',\n  description: 'Set properties for fields of a specific type (number, string, boolean)',\n  optionsToLabel: (options) => options,\n};\n"],"names":["React"],"mappings":"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"}